<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML><HEAD><TITLE>Advanced Dynamic Matrix Documentation</TITLE></HEAD>
<BODY BGCOLOR="#AAACCC">
<H1>Advanced Dynamic Matrix Documentation</H1>
Matrices are useful, common data
structures. These are high-level dym/dyv/ivec extensions that don't pierce the
abstraction layer.
<HR>
Usage:
<UL>
	<LI>#include "amdmex.h" (in <B>utils/</B> )
	<LI>Link with libutils.a (if you're using the auton build system, list utils as a sibling)
</UL>
<HR>

<TABLE BORDER=1 BGCOLOR="palegreen">
	<TR><TH>Function Name<TH>Description<TH>Errors/Notes</TR>
	<TR><TD>dyv* <B>mk_reverse_dyv</B>(dyv* x)<TD>Creates a new dyv which is the reverse of the provided dyv
	<TR><TD>ivec* <B>mk_reverse_ivec</B>(ivec* x)<TD>Creates a new ivec which is the reverse of the provided ivec
	<TR><TD><B>append_to_dyv</B>(dyv* x, dyv* y)<TD>Append y to the end of x
	<TR><TD><B>append_to_ivec</B>(ivec* x, ivec* y)<TD>Append y to the end of x
	<TR><TD>dyv* <B>mk_dyv_append</B>(dyv* x, dyv* y)<TD>Return contents of x with y appended
	<TR><TD>ivec* <B>mk_ivec_append</B>(ivec* x, ivec* y)<TD>Return contents of x with y appended
	<TR><TD>dyv* <B>mk_dyv_range_random</B>(dyv* low, dyv* high)<TD>???
	<TR><TD><B>dym_increment_block</B>(dym* a, int ilo, int jlo, int ihi, int jhi, double delta)<TD>In a, increment all values within the specified 2d block by delta
	<TR><TD><B>dyv_increment_block</B>(dym* a, int ilo, int ihi, double delta)<TD>In a, increment all values within the specified block by delta
	<TR><TD><B>indices_of_sorted_dyv</B>(dyv* dv, ivec* iv)<TD>updates iv so that dereferencing through it is through a sorted index
	<TR><TD>ivec* <B>mk_indices_of_sorted_dyv</B>(dyv* dv)<TD>Returns an ivec so that dereferencing through it is through a sorted index
	<TR><TD>ivec* <B>mk_indices_of_sorted_ivec</B>(ivec* v)<TD>Returns an ivec so that dereferencing through it is through a sorted index
	<TR><TD>dyv* <B>mk_sorted_dyv</B>(dyv* x)<TD>Returns a new, sorted copy of x
	<TR><TD><B>sorted_eigens_of_spd_dym</B>(dym* d, dym* evectors, dyv* evalues)<TD>Does a svd, places the sorted eigenvectors and values in evectors and evalues
	<TR><TD>dyv* <B>mk_sorted_eigens_of_spd_dym</B>(dym* d)<TD>Does a svd, returns the sorted eigenvalues
	<TR><TD><B>random_unit_dyv</B>(dyv* d)<TD>Fills d with a randomly chosen vector of magnitude 1
	<TR><TD>dyv* <B>mk_random_unit_dyv</B>(int size)<TD>returns a random vector of magnitude 1
	<TR><TD>bool <B>dyv_weakly_dominates</B>(dyv* dx, dyv* dy)<TD>TRUE if all elements of dx are &gt;= corrisponding element in dy
	<TR><TD>bool <B>dym_weakly_dominates</B>(dym* dx, dym* dy)<TD>TRUE if all elements of dx are &gt;= corrisponding element in dy
	<TR><TD>bool <B>double_equal</B>(double x, double y)<TD>TRUE if x and y are sufficiently close
	<TR><TD>bool <B>dyv_equal</B>(dyv* dx, dyv* dy)<TD>TRUE if all values of dx and dy are sufficiently close to their corrispondant
	<TR><TD>bool <B>dym_equal</B>(dym* dx, dym* dy)<TD>TRUE if all values of dx and dy are sufficiently close to their corrispondant
	<TR><TD>double <B>sum_of_dym_diff_squares</B>(dym* d1, dym* d2)<TD>Returns the least squares difference sum of the two matrices
	<TR><TD>dym* <B>mk_subdym</B>(dym* dm, ivec* goodrows, ivec* goodcols)<TD>Returns a new dym with the specified rows and columns included
	<TR><TD>dym* <B>mk_subdym_complement</B>(dym* dm, ivec* badrows, ivec* badcols)<TD>Returns a new dym with the specified rows and columns excluded
	<TR><TD>double <B>check_robust_cholesky_factorization</B>(dym* a, ivec* goodlist)<TD>Do robust cholesky, and verify
	<TR><TD><B>normalize_dyv</B>(dyv* src, dyv* dest)<TD>Places normalized copy of syc dyv into dest
	<TR><TD>dyv* <B>mk_normalize_dyv</B>(dyv* d)<TD>Returns normalized copy of the dyv
	<TR><TD>double <B>dyv_partial_sum</B>(dyv* dv, ivec* indices)<TD>Returns sum of elements indexed by indices
	<TR><TD>double <B>dyv_sparse_scalar_product</B>(dyv* dv, dyv* dv2, ivec* goodlist)<TD>Returns sum of products of corrisponding elements in dv and dv2 that are listed in goodlist
	<TR><TD><B>dyv_clip_in_unit</B>(dyv* dv)<TD>???
	<TR><TD>dyv* <B>mk_dyv_clip_in_unit</B>(dyv* dv)<TD>???
	<TR><TD><B>random_rotation</B>(dym* d)<TD>???
	<TR><TD><B>fprintf_dyv_for_load</B>(FILE* s, dyv* d, char* comment)<TD>Saves a dyv onto one line of the provided file, with the provided comment
	<TR><TD>dyv* <B>mk_dyv_from_file</B>(FILE* fp, char** r_errmess)<TD>Load a dyv stored by the above function
	<TR><TD><B>fprintf_oneline_dyv</B>(FILE* s, char* m1, dyv* d, char* m2)<TD>Prints out a dyv with the pre and post strings
	<TR><TD>ivec* <B>mk_random_ivec_subset</B>(ivec* iv, int size)<TD>Returns a random subset of specified size of the provided ivec
	<TR><TD>ivec* <B>mk_random_ivec_subset_fast</B>(ivec* iv, int size)<TD>Returns a random subset of specified size of the provided ivec<TD>Same as above, but faster? Do we lose anything?
	<TR><TD>ivec* <B>mk_random_small_subset</B>(int n, int size, ivec* seed)<TD>Returns a random subset of the numbers 0..n-1 of the specified size. If seed is not NULL, will guarantee that all numbers in the seed are present in the returned value<TD>What if size is smaller than seed?
	<TR><TD><B>append_to_ivec</B>(ivec* target, ivec* addend)<TD>Adds the contents of addent to the target
	<TR><TD>ivec* <B>mk_ivec_from_dyv</B>(dyv* d)<TD>Returns an ivec that approximates the provided dyv (double-&gt;int)
	<TR><TD>dyv* <B>mk_dyv_from_ivec</B>(ivec* iv)<TD>Returns a dyv from the provided ivec (int-&gt;double)
	<TR><TD>ivec* <B>mk_ivec_from_args</B>(char* key, int argc, char** argv, ivec* def)<TD>Returns an ivec from CL arguments, or from the provided default if none are provided
	<TR><TD><B>copy_dym_row</B>(dym* source, int src_row, dym* dest, int dst_row)<TD>Copies a dym row from one dym to another
	<TR><TD><B>copy_dym_col</B>(dym* source, int src_col, dym* dest, int dst_col)<TD>Copies a dym col from one dym to another
	<TR><TD><B>swap_dym_rows</B>(dym* dm, int i, int j)<TD>Swaps two rows in the provided dym
	<TR><TD><B>swap_dym_cols</B>(dym* dm, int i, int j)<TD>Swaps two cols in the provided dym
	<TR><TD>double <B>dyv_sum</B>(dyv* dv)<TD>Returns the sum of all values in provided dyv
	<TR><TD>double <B>sum_of_dyv_rows</B>(dyv* dv, ivec* rows)<TD>Returns the sum of all values in the specified rows of the provided dyv. If rows is NULL, will use all rows<TD>Badly named -- dyvs don't have rows or columns! They're 1d
	<TR><TD><B>sum_of_dym_rows</B>(dym* dm, ivec* rows, dyv* recip)<TD>Places the sums of all values in the specified rows of the provided dym into recip. If rows is NULL, will use all rows
	<TR><TD>dyv* <B>mk_sum_of_dym_rows</B>(dym* dm, ivec* rows)<TD>Returns the sums of all values in the specified rows of the provided dym. If rows is NULL, will use all rows
	<TR><TD>dyv* <B>mk_sum_of_dym_cols</B>(dym* dm, ivec* cols)<TD>Returns the sums of all values in the specified cols of the provided dym. If cols is NULL, will use all cols
	<TR><TD>dyv* <B>mk_sumsq_of_dym_cols</B>(dym* dm, ivec* cols)<TD>Returns the sum square of all values in the specified cols of the provided dym. If cols is NULL, will use all cols
	<TR><TD>dyv* <B>mk_sumsq_of_dym_rows</B>(dym* dm, ivec* rows)<TD>Returns the sum squared of all values in the specified rows of the provided dym. If rows is NULL, will use all rows
	<TR><TD>dyv* <B>mk_sumcube_of_dym_rows</B>(dym* dm, ivec* rows)<TD>Returns the sum cube of all values in the specified rows of the provided dym. If rows is NULL, will use all rows
	<TR><TD>dyv* <B>mk_mean_of_dym_rows</B>(dym* dm, ivec* rows)<TD>Returns the mean of all values in the specified rows of the provided dym. If rows is NULL, will use all rows
	<TR><TD>dyv* <B>mk_mean_of_dym_cols</B>(dym* dm)<TD>Returns the mean of all values in the specified cols of the provided dym. If cols is NULL, will use all cols<TD>Note that the arguments are different than rows version!!
	<TR><TD>dym* <B>mk_covariance_of_dym_rows</B>(dym* dm, dyv* mean, ivec* rows)<TD>???
	<TR><TD>dym* <B>mk_diag_covariance_of_dym_rows</B>(dym* dm, dyv* mean, ivec* rows)<TD>???
	<TR><TD>dyv* <B>mk_sdev_of_dym_rows</B>(dym* dm, ivec* rows)<TD>Returns the standard deviation of all values in the specified rows of the provided dym. If rows is NULL, will use all rows
	<TR><TD>dyv* <B>mk_sum_of_dyv_array_rows</B>(dyv_array* da, ivec* rows, int dyv_length)<TD>Return vector consisting of sums of rows mentioned in the ivec @rows. If rows is NULL, will use all rows. If rows is empty, will return vector of size dyv_length containing all zeroes
	<TR><TD><B>explain_dyv_array</B>(dyv_array* da, ivec* rows)<TD>???
	<TR><TD><B>pdyv_array</B>(dyv_array* da)<TD>???
	<TR><TD>bool <B>dyv_array_equal</B>(dyv_array* da1, dyv_array* da2)<TD>TRUE if the dyv arrays have the same contents
	<TR><TD>dyv* <B>mk_dyv_array_sum</B>(dyv_array* sps, ivec* rows)<TD>Returns a dyv containing the sums of the specified columns in the provided dyv array
	<TR><TD>dyv* <B>mk_dyv_array_centroid</B>(dyv_array* sps, ivec* rows)<TD>???
	<TR><TD>ivec* <B>mk_dyv_lengths</B>(dyv_array* da)<TD>???
	<TR><TD>int <B>dyv_array_num_dims</B>(dyv_array* da)<TD>???
	<TR><TD>ivec* <B>mk_ivec_from_dym_col</B>(dym* a, int col)<TD>Returns an ivec with a copy of the requested column
	<TR><TD>ivec* <B>mk_ivec_from_dym_row</B>(dym* a, int row)<TD>Returns an ivec with a copy of the requested row
	<TR><TD><B>diag_times_dyv</B>(dyv* a, dyv* b, dyv* targ)<TD>Maps multiply over a and b, storing in targ
	<TR><TD>dyv* <B>diag_times_dyv</B>(dyv* a, dyv* b)<TD>Maps multiply over a and b, returning results
	<TR><TD>dyv_array* <B>mk_empty_dyv_array</B>()<TD>Makes an empty dyv_array
	<TR><TD>dym_array* <B>mk_empty_dym_array</B>()<TD>Makes an empty dym_array
	<TR><TD><B>add_to_dyv_array</B>(dyv_array* targ, dyv* addend)<TD>Adds contents of another dyv into a dyv_array
	<TR><TD><B>add_to_dym_array</B>(dym_array* targ, dym* addend)<TD>Adds contents of another dym into a dym_array
	<TR><TD>int <B>dyv_array_size</B>(dyv_array* dyv)<TD>Returns size of the specified dyv_array
	<TR><TD>int <B>dym_array_size</B>(dym_array* dym)<TD>Returns size of the specified dym_array
	<TR><TD>dyv* <B>safe_dyv_array_ref</B>(dyv_array* da, int index)<TD>Returns a pointer to the specified dyv inside the passed dyv_array
	<TR><TD>dym* <B>dym_array_ref</B>(dym_array* da, int index)<TD>Returns a pointer to the specified dym inside the passed dym_array
	<TR><TD>dyv_array* <B>make_array_of_zero_length_dyvs</B>(int size)<TD>Makes an array of zero-length dyvs of the specified size
	<TR><TD>dyv_array* <B>make_array_of_null_dyvs</B>(int size)<TD>Makes an array of null (?) dyvs of the specified size
	<TR><TD>dyv_array* <B>make_dyv_array</B>(int size)<TD>Makes an array of empty dyvs of the specified size
	<TR><TD>dyv_array* <B>make_dyv_array_subset</B>(dyv_array* da, ivec* indices)<TD>???
	<TR><TD><B>fprintf_dym_array</B>(FILE* s, char* text, dym_array* da, char* post)<TD>prints the contents of the specified dym array to the given filehandle
	<TR><TD><B>pdym_array</B>(dym_array* da)<TD>prints the contents of the specified dym array to stdout
	<TR><TD><B>free_dym_array</B>(dym_array* da)<TD>Frees the specified dym_array
	<TR><TD>dym_array* <B>mk_copy_dym_array</B>(dym_array* da)<TD>Returns a copy of the specified dym_array
	<TR><TD>dyv* <B>mk_dyv_from_string_array_with_error_message</B>(string_array* sa, char* format, char** err_msg)<TD>Returns a dyv with numeric form of numbers in the provided string array. If format is specified, it should be the same length as the string array, containing the characters i and -, the i indicating that position should be ignored, and the - indicating that it should be skipped.<TD>Returns null if there's a problem, setting err_msg. This function is confusing.
	<TR><TD>dyv* <B>mk_dyv_from_string_with_error_message</B>(char* str, char* format, char** err_msg)<TD>Returns a dyv with numeric form of numbers in the provided string. If format is specified, it should have the same length as there are fields in the string, containing the characters i and -, the i indicating that position should be ignored, and the - indicating that it should be skipped.<TD>Returns null if there's a problem, setting err_msg. This function is confusing.
	<TR><TD>dyv* <B>mk_dyv_from_string_array</B>(string_array* sa, char* format)<TD>Same as the above, but no error message
	<TR><TD>dyv* <B>mk_dyv_from_string</B>(char* str, char* format)<TD>Same as above, but with no error message
	<TR><TD>dyv* <B>mk_io_dyvs_from_string</B>(char* str, char* format, dyv** r_in_dyv, dyv** r_out_dyv)<TD>???
	<TR><TD>string_array* <B>mk_string_array_from_dyv</B>(dyv* d)<TD>???
	<TR><TD>char* <B>mk_string_from_dyv</B>(dyv* d)<TD>???
	<TR><TD>dyv_array* <B>mk_array_of_zeroed_dyvs</B>(int num_dyvs, int dyv_size)<TD>???
	<TR><TD>dym_array* <B>mk_dym_array_of_zeroed_dyms</B>(int num_dyms, int dym_size)<TD>???
	<TR><TD>dym_array* <B>mk_dym_array_of_zeroed_nonrect_dyms</B>(int num_dyms, int dym_size_r, int dym_size_c)<TD>???
	<TR><TD>void <B>zero_dym_array</B>(dym_array* da)<TD>???
	<TR><TD>dyv* <B>mk_midpoint_dyv</B>(dyv* a, dyv* b)<TD>???
	<TR><TD>double* <B>median_of_three</B>(double x, double y, double z)<TD>Huh?
	<TR><TD>int <B>find_index_of_kth_smallest</B>(dyv* x, int k)<TD>Finds the index of the kth smallest element in the provided dyv
	<TR><TD>double <B>dyv_kth_smallest</B>(dyv* x, int k)<TD>Finds the value of the kth smallest element in the provided dyv
	<TR><TD>double <B>dyv_median</B>(dyv* x)<TD>Finds the median value of the provided dyv
	<TR><TD>void <B>save_dym_to_file</B>(FILE* s, dym* m)<TD>Saves the listed dym to a file
	<TR><TD>dym* <B>mk_dym_from_file</B>(FILE* s, char** r_errmess)<TD>Loads a dym from the listed file<TD>Should've been created by save_dym_to_file()
	<TR><TD>string_array* <B>mk_string_array_from_stream</B>(FILE* s, char** r_errmess)<TD>???
	<TR><TD><B>save_string_array_to_stream</B>(FILE* s, string_array* sa)<TD>???
	<TR><TD><B>save_dyv_to_stream</B>(FILE* s, dyv* v)<TD>???
	<TR><TD>dyv* <B>mk_dyv_from_stream</B>(FILE* s, char** r_errmess)<TD>???
	<TR><TD><B>save_ivec_to_stream</B>(FILE* s, ivec* v)<TD>???
	<TR><TD>ivec* <B>mk_ivec_from_stream</B>(FILE* s, char** r_errmess)<TD>???
	<TR><TD><B>maybe_prepend_errmess</B>(char* filename, char* direction, char* thing, char** r_errmess)<TD>???

</TABLE>

<H1>Implementation</H1>
These are just extensions.
</BODY></HTML>
