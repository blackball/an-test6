\documentclass[journal]{IEEEtran}
\usepackage{url}
\usepackage{amsmath}
\usepackage{amsfonts}

\newcommand{\x}{\mathbf{x}}

\begin{document}
\title{The Painless KDtree Tutorial}
\author{Dustin~Lang,
        Keir~Mierle,
        and~Sam~Roweis}% <- '%' to prevent space
\maketitle

\begin{abstract}
  The kdtree is a simple data structure which has a long history and a
  significant amount of folklore surrounding it.
  This tutorial explains modern usage and implementation of the kdtree.
\end{abstract}

\section{Introduction}
\PARstart{T}{he} kdtree is a simple data structure for indexing a set of
$k$-dimensional points.
Each node in the tree owns a subset of the data points; the root node owns
all the data points, and each point owned by a parent node is owned by exactly
one child node.  A kdtree is built by choosing a 
``splitting dimension'' and ``splitting value'' at each non-leaf node.
The data points owned by the node are partitioned by placing a hyperplane
perpendicular to the axis of the splitting dimension, at the splitting value along
the splitting axis.  Points that lie on one side of the hyperplane (ie, whose position
along the splitting dimension is greater than the splitting value) are given to the
right child, and those on the other side are given to the left child.

%A hyperplane perpendicular to the splitting axis
%In effect, the region of space owned by a parent node is divided in two by a
%hyperplane aligned with the coordinate axes; points one on side of the plane belong to
%the right child, and points on the other side belong to the left child.

%``splitting dimension'' and ``splitting value'' at each non-leaf node.
%  Data points whose position along the
%splitting dimension is greater than the splitting value are given to one child,
%while those whose value is less than the splitting value are given to the other child.
%In effect, the region of space owned by a parent node is divided in two by a
%hyperplane aligned with the coordinate axes; points one on side of the plane belong to
%the right child, and points on the other side belong to the left child.

%In addition, at
At each node in the tree a number of ``cached statistics'' are stored.
Most common is the bounding box: a hyper-rectangle that (tightly) bounds
the data points owned by the node.
% Bounding box is composed of the lower- and upper-bound points, which are dimensionwise
% minimum and maximum of the data points owned by the node.
  A kdtree has the property that sibling bounding
boxes do not overlap, and a child node's bounding box is a subset of the parent's
bounding box.

An alternative to storing the bounding box at each node is to store the splitting dimension
and splitting value.  This is a less powerful, but more compact, representation.

%Each non-leaf node may also store the splitting dimension and value.  This is a less powerful
%but more compact representation of the tree, compared to storing the bounding boxes.

%Each node in the tree owns a region of the $k$-dimensional space; child nodes
%own a subset of the space owned by their parents.
%The region owned by a node is a hyper-rectangle whose sides are
%parallel to the axes.
%At each non-leaf node, the space is split along one dimension, and data point
%Each non-leaf node splits its space along one 


Other cached statistics might include the centroid or second moment of the data points.


Cached statistics are stored in the tree in order to allow queries to be accelerated.
The classical query is range search: return all data points within a given radius
(typically using the Euclidean metric)
of a query point.  By storing the bounding box, we can quickly check if a sphere centered
at the query point with the given search radius intersects the bounding box.  If it does not,
no point owned by the node can possibly be part of the result set, so we need not descend
the tree further.

%% FIX - be consistent with phrases like ``descend'' the tree, traverse, search, etc.

% FIX - why axis-aligned bounding boxes?  --> very quick min/maxdist, membership test,


\section{Building a kdtree}

Construction of a kdtree begins by computing the axis-aligned bounding box of the 
data points (which will be the bounding box of the root node).
(The corners of this bounding box are simply the dimensionwise minima and maxima.)
We then choose a splitting dimension and splitting value, and partition the data
points into the sets of points that belong to the left and right children.  Finally, the
children's bounding boxes are computed and the procedure repeats on each child node.
This process stops once a node contains fewer than a desired maximum number of points.

The splitting dimension and value can be chosen a number of ways.  Common choices
include choosing the dimension with the largest variance or the largest range
(maximum - minimum).  The splitting value is often chosen to be the median value so
that the left and right children own an equal number of data points; this typically results
in a balanced, full, binary tree.

An important implementation decision is how to store the set of points owned by each
node.  Clearly, we want to avoid duplicating the data values at each level of the tree.
One option is to create a permutation vector (initialized to the identity permutation)
which is shuffled during tree construction
such that the indices of points owned by the left child are in the first half of the vector
and points owned by the right child are in the second half.  Then each node must store
the offset and length of the segment of the permutation vector that it owns; the indices of
the data points it owns are contained in that segment of the permutation vector.
The benefit of this scheme is that the data points themselves need not be shuffled or duplicated;
it does however incur the cost of a level of indirection when accessing the data points,
and requires an extra vector to be stored.


% Decide where along that dimension to split
 

\section{Range search}

\subsection{Bounding box}



\subsection{Split dimension/value}










\begin{thebibliography}{1}

\bibitem{IEEEhowto:kopka}
H.~Kopka and P.~W. Daly, \emph{A Guide to {\LaTeX}}, 3rd~ed.\hskip 1em plus
  0.5em minus 0.4em\relax Harlow, England: Addison-Wesley, 1999.

\end{thebibliography}

\end{document}

