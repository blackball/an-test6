The quads system uses a variety of files, which I'll describe below.

The binary files all start with the unsigned short int MAGIC_VAL
(#defined at the end of fileutil.h) which helps identify them as
binary and also sort out endian issues. 

[dstn note:
   "unsigned short int" => u16_t
   "unsigned long int"  => u32_t
   "int"                => probably i32_t
]

1) Catalogue Files (.objs) -- binary

The binary catalogue format (.objs) is as follows:
   unsigned short int = MAGIC_VAL
   unsigned long int = number_of_stars_in_catalogue
   unsigned short int = dimension_of_space (almost always==3)
   double ramin = minimum RA value of all stars
   double ramax = maximum RA value of all stars
   double decmin = minimum DEC value of all stars
   double decmax = maximum DEC value of all stars
   double x0, double y0, double z0
   double x1, double y1, double z1
   ...


2) KD Tree Files (.skdt .ckdt) -- binary

The binary star KD-tree (.skdt) files have this format:

   KD-tree-in-binary-format (see below)
   double ramin = minimum RA value of all stars
   double ramax = maximum RA value of all stars
   double decmin = minimum DEC value of all stars
   double decmax = maximum DEC value of all stars

The binary code KD-tree (.ckdt) files have this format:

   KD-tree-in-binary-format (see below)
   double scale = scale of quads in arcmin

(Notice -- and this is a bug -- that these files DO NOT start with MAGIC_VAL)

The binary format for a KD-tree is as follows:

   int numnodes = total number of nodes (leaf+nonleaf+root) in KD-tree
   int maxdepth = maximum depth (number of levels; root is level 1)
   int rmin = maximum number of points per leaf node (why is it called rmin?)
   node1 (see below)
   node2
   ...
   nodeN

where the order of nodes is a DEPTH FIRST traversal of the
binary tree, starting at the left and expanding left children
then right children

The binary format for a node in a KD-tree is as follows

   int numpoints = 0 if node is null
                 = +K for a leaf node containing K points directly
                 = -K for an interior node whose subtree contains K points
   double min_x  = minimum corner of bounding box
   double min_y    which surrounds all points living in node (if leaf)
   double min_z    or in subtree rooted by this node (if nonleaf)
   double max_x  = maximum corner of bounding box
   double max_y
   double max_z

and, if the node is a leaf node, this is followed by

   int idx1   indices of K points living in this leaf node
   int idx2
   ...
   int idxK  
   double x1  x,y,z coordinates of K points living in this leaf node
   double y1
   double z1
   double x2
   double y2
   double z2
   ...
   double xK
   double yK
   double zK


3) Code (.code) files

   these files store the codes (ie the 4-vectors in codespace) for each quad

   unsigned short int = MAGIC_VAL
   unsigned long int numCodes = number of codes (quads) in this codefile
   unsigned short int DimCodes = dimension of codes (almost always 4)
   double index_scale = scale of quads (arcmin)
   unsigned long int numstars = number of stars in original catalogue (unclear)
   double c11 code elements for first quad
   double c12
   double c13
   double c14
   double c21 code elements for second quad
   double c22
   double c23
   double c24
   ...
   double cN1 code elements for last (Nth) quad
   double cN2
   double cN3
   double cN4


4) Quad (.quad) files

   these files store the identities of the stars (acording to the
   order the appeared in the catalogue) which make up each quad

   unsigned short int = MAGIC_VAL
   unsigned long int numQuads = number of quads (codes) in this quadfile
   unsigned short int DimQuads = number of stars per quad (almost always 4)
   double index_scale = scale of quads (arcmin)
   unsigned long int numstars = number of stars in original catalogue (unclear)
   unsigned long int idxA1 = index of A star in quad 1 
   unsigned long int idxB1 = index of B star in quad 1 
   unsigned long int idxC1 = index of C star in quad 1 
   unsigned long int idxD1 = index of D star in quad 1 
   unsigned long int idxA2 = index of A star in quad 2 
   unsigned long int idxB2 = index of B star in quad 2 
   unsigned long int idxC2 = index of C star in quad 2 
   unsigned long int idxD2 = index of D star in quad 2 
   ...
   unsigned long int idxAN = index of A star in quad N 
   unsigned long int idxBN = index of B star in quad N 
   unsigned long int idxCN = index of C star in quad N 
   unsigned long int idxDN = index of D star in quad N 


5) Inverted Index (.qidx) files

   these file store, for each star in the original catalogue which was
   used, a list of which quads the star appears in

   unsigned short int = MAGIC_VAL
   unsigned long int numQuads = number of quads (codes) in this index
   unsigned long int star_idx_1 = index of first star used
   unsigned long int num_quads_1 = number of quads this star appears in
   unsigned long int quad_num_11 = first quad it appears in
   unsigned long int quad_num_12
     ...
   unsigned long int quad_num_1K1 = last quad it appears in
   unsigned long int star_idx_2 = index of second star used
   unsigned long int num_quads_2   etc...
   unsigned long int quad_num_21
   unsigned long int quad_num_22
     ...
   unsigned long int quad_num_2K2
   ...
   unsigned long int star_idx_N
   unsigned long int num_quads_N
   unsigned long int quad_num_N1
   unsigned long int quad_num_N2
   ...
   unsigned long int quad_num_NKN


6) Hits (.hits) files

Hits files describe the results of a solver run, i.e. solvexy outputs a single
.hits file each time it runs. The format is a Python dictionary, such that the
.hits file can be loaded and eval'd to get at the information.

The files start with a header describing the details of this particular run.

-------------------------------------------------------------------------------
dict(
# SOLVER PARAMS:
# solving fields in astrom_galex_blind_test_ais_01.FUVtop100.xyls using ../an_usno                  _galex_04.ckdt
field_to_solve = 'astrom_galex_blind_test_ais_01.FUVtop100.xyls',
index_used = '../an_usno_galex_04.ckdt',
nfields = 1,
nquads = 13055630,
objects_in_catalog = 786432,
code_tol = 0.001000,
agree_tol = 5.000000,
parity_flip = False,
min_matches_to_agree = 6,
max_matches_needed = 8,
# debugging of failed matches enabled; outputting matches in region:
debug_ra = (359.500000, 0.580000),
debug_dec = (-11.400000, -10.200000),
--------------------------------------------------------------------------------

The fields are pretty self-describing.

If debugging is enabled (-d -D -r -R all specified), then the debugging window
is enabled. For fields that don't solve, any hits in that region get reported
despite the field not solving.

Then, the results for each field are stored as a list of dictionaries.

--------------------------------------------------------------------------------
results = [ 
# --------------------
dict(
    field=0,
    objects_in_field=100,
    # Image corners
    min_uv_corner=(565.648438,577.835449), max_uv_corner=(3134.257080,3360.867432),
    quads_tried=22297, codes_matched=32,
    # 19 matches agree on resolving of the field:
    matches_agree=19,

          For fields that matched, each quad is listed with details about. The
          quads are in a list, with each quad a dictionary like the one below.

    quads=[
        dict(
            quad=3034834,
            starids_ABCD=(13024,28552,22497,58679),
            field_objects_ABCD=(7,47,25,14),
            min_xyz=(0.980323,0.009857,-0.197152), min_radec=(0.576064,-11.370458),
            max_xyz=(0.984121,-0.008832,-0.177282), max_radec=(359.485823,-10.211463),
        ),
	
	.... more dictionaries for each matched quad in the field

    ],

          Then there is two more dictionaries to map between stars and catalog
          objects.

    # Field Object <--> Catalogue Object Mapping Table
    field2catalog={
        2 : 25521,
        4 : 14047,
        7 : 13024,
        10 : 13025,
        12 : 36182,
        14 : 58679,
        18 : 43428,
        19 : 13014,
        21 : 71187,
        25 : 22497,
        26 : 14884,
        47 : 28552,
    },
    catalog2field={
        25521 : 2,
        14047 : 4,
        13024 : 7,
        13025 : 10,
        36182 : 12,
        58679 : 14,
        43428 : 18,
        13014 : 19,
        71187 : 21,
        22497 : 25,
        14884 : 26,
        28552 : 47,
    },
),


         ... This is repeated for each field

], 
# END OF RESULTS
############################################################

)
--------------------------------------------------------------------------------

And that's all there is to the .hits files.

7) XY List (.xyls) files

	These are ASCII files, which hold the xy positions of detected
	sources and have the following format:

   NumFields=N
   S1,x11,y11,x12,y12,...,x1K1,y1K1
   S2,x21,y21,x22,y22,...,x2K2,y2K2
   ...
   SN,xN1,yN1,xN2,yN2,...,xNKN,yNKN

each line after the first corresponds to a single field and
holds an integer saying how many sources are in that field and then
a sequence of pairs of reals giving the xy positions of those sources

the file should have exactly N+1 lines if it describes N fields,
and commas should be used to separate, as above


