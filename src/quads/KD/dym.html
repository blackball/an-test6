<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML><HEAD><TITLE>Dynamic Matrix Documentation</TITLE></HEAD>
<BODY BGCOLOR="#AAACCC">
<H1>Dynamic Matrix Documentation</H1>
Matrices are useful, common data
structures. Our implementation of Dynamic Matrices (dyms) allows
for (semi)easy resizing and provides useful operations
over the members. Our dynamic matrices (dyms) hold values of the type
<B>double</B>.<br><br>
<HR>
Usage:
<UL>
	<LI>#include "amdym.h" (in <B>utils/</B> )
	<LI>Link with libutils.a (if you're using the auton build system, list utils as a sibling)
</UL>
<HR>

Basic Size/Allocation Operations
<TABLE BORDER=1 BGCOLOR="palegreen">
	<TR><TH>Function Name<TH>Description<TH>Performance<TH>Errors</TR>
	<TR><TD>dym* <B>mk_dym</B>(int rows, int cols)<TD>Creates a new dym with requested dims<TD>Do we initialize to anything in particular? Do we sanity-check the rows/cols values for negative/zeros?<TD>
	<TR><TD>dym* <B>mk_dym_x</B>(int rows, int cols, double val...)<TD>Creates a new dym with requested dims, initialized to specified values.<TD>Is it safe to pass fewer/more initializers than the size? Do we sanity-check the rows/cols values for negative/zeros? This function is probably a bit dangerous.<TD>
	<TR><TD>dym* <B>mk_constant_dym</B>(int rows, int cols, double v)<TD>Creates a new dym with requested dims and all values set to v<TD>Do we sanity-check the rows/cols values for negative/zeros?<TD>
	<TR><TD>dym* <B>mk_zero_dym</B>(int rows, int cols, double v)<TD>Creates a new dym with requested dims and all values set to 0.0<TD>Do we sanity-check the rows/cols values for negative/zeros?<TD>
	<TR><TD>dym* <B>mk_identity_dym</B>(int dims)<TD>Makes an identity matrix of the given length/width<TD>???<TD>
	<TR><TD>dym* <B>mk_dym_from_string</B>(char* s)<TD>Creates a dym from the supplied string<TD>???<TD>
	<TR><TD>dym* <B>mk_dym_from_args</B>(char* name, int argc, char** argv, dym* deflt)<TD>Creates a dym from the supplied program arguments, using provided default value if the program arguments are insufficient<TD>???<TD>
	<TR><TD><B>free_dym</B>(dyn* this_dym)<TD>Frees this dym<TD><TD>
	<TR><TD><B>add_row</B>(dym* this_dym)<TD>Adds a new row to $this_dym at position (FIND THIS OUT)<TD>What are the row elements initialized to?
	<TR><TD><B>dym_remove_row</B>(dym* this_dym, int row)<TD>removes the specified row from @this_dym<TD>What are the row elements initialized to?
	<TR><TD><B>dym_restructive_resize</B>(dym* this_dym, int rows, int cols))<TD>Reinitializes dym with a different size, losing all stored elements<TD>
	<TR><TD>int <B>dym_rows</B>(dym* this_dym)<TD>Returns the number of rows in the dym<TD>
	<TR><TD>int <B>dym_cols</B>(dym* this_dym)<TD>Returns the number of cols in the dym<TD>
	<TR><TD><B>save_dym</B>(FILE* s, dym* this_dym)<TD>Saves a dym in XXX format to a file<TD>
	<TR><TD><B>save_io_dyms</B>(FILE* s, dym* ins, dym* outs)<TD>???<TD>
	<TR><TD><B>can_read_io_dyms</B>(char* fname, char* format, dym** r_in_dym, dym** r_out_dym)<TD>???<TD>
	<TR><TD><B>read_dym</B>(FILE* s, char fname, char* format)<TD>???<TD>
	<TR><TD><B>assert_dym_shape</B>(dym* d, int rows, int cols, char* name)<TD>Fails if @d isn't of the specified shape<TD>
</TABLE>

Basic Operations
<TABLE BORDER=1 BGCOLOR="white">
	<TR><TH>Function Name<TH>Description<TH>Performance<TH>Errors</TR>
	<TR><TD>double <B>dym_ref</B>(dym* mydym, int i, int j)<TD>Retrieves value at position (i,j)<TD>
	<TR><TD><B>dym_set</B>(dym* mydym, int i, int j, double value)<TD>Sets the member at position [i][j] to value<TD>
	<TR><TD><B>dym_increment</B>(dym* mydym, int i, int j, double value)<TD>???<TD>
	<TR><TD><B>copy_dym_row_to_dym_row</B>(dym* src, int src_row, dym* dst, int dst_row)<TD>Copies a row from one dym to another<TD>Does this do bounds checking? Can one dym be both src and target? What if you try to copy a row over itself? What if one dym is bigger than the other?
	<TR><TD><B>copy_dym_col_to_dym_col</B>(dym* src, int src_col, dym* dst, int dst_col)<TD>Copies a col from one dym to another<TD>Does this do bounds checking? Can one dym be both src and target? What if you try to copy a col over itself? What if one dym is bigger than the other?
	<TR><TD><B>copy_dyv_to_dym_col</B>(dyv* my_dyv, dym* my_dym, int col)<TD>Copies a dyv into the specified col of the dym<TD>Does this do bounds checking? What if the dyv is bigger than the colsize?
	<TR><TD><B>copy_dyv_to_dym_row</B>(dyv* my_dyv, dym* my_dym, int row)<TD>Copies a dyv into the specified row of the dym<TD>Does this do bounds checking? What if the dyv is bigger than the rowsize?
	<TR><TD><B>copy_dym_row_to_dyv</B>(dym* my_dym, dyv* dv, int row)<TD>Copies a dym row into a dyv<TD>Does this do bounds checking? What if the sizes mismatch?
	<TR><TD><B>copy_dym_col_to_dyv</B>(dym* my_dym, dyv* dv, int col)<TD>Copies a dym col into a dyv<TD>Does this do bounds checking? What if the sizes mismatch?
	<TR><TD>dyv* <B>mk_dyv_from_dym_col</B>(dym* my_dym, int col)<TD>Creates a dyv from a dym col<TD>
	<TR><TD>dyv* <B>mk_dyv_from_dym_row</B>(dym* my_dym, int row)<TD>Creates a dyv from a dym row<TD>
	<TR><TD>dym* <B>mk_col_dym_from_dyv</B>(dyv* my_dyv)<TD>???<TD>
	<TR><TD>dym* <B>mk_row_dym_from_dyv</B>(dyv* my_dyv)<TD>???<TD>
	<TR><TD>dym* <B>mk_diag_dym_from_dyv</B>(dyv* my_dyv)<TD>Returns a diagonal matrix made from the supplied dyv<TD>
	<TR><TD><B>append_dyv_to_dym</B>(dym* mydym, dyv* row)<TD>Adds new row to @mydym, source is the given dyv<TD>
	<TR><TD><B>append_dym_to_dym</B>(dym* dym1, dym* dym2)<TD>???<TD>
	<TR><TD><B>constant_dym</B>(dym* my_dym, double v)<TD>Fills in all slots in my_dym with the value v<TD>
	<TR><TD><B>zero_dym</B>(dym* my_dym)<TD>Resets all values in my_dym with 0.0<TD>
	<TR><TD><B>copy_dym</B>(dym* my_dym, dym* target)<TD>Copies the elements of @my_dym into @target<TD>
	<TR><TD>dym* <B>mk_copy_dym</B>(dym* my_dym)<TD>Copies the elements of @my_dym into the returned dym<TD>
	<TR><TD><B>pdym</B>(dym* my_dym)<TD>Prints the given dym<TD>
	<TR><TD><B>fprintf_dym</B>(FILE* s, char* m1, dym* d, char* m2)<TD>???<TD>
	<TR><TD><B>fprintf_dym_and_confidence</B>(FILE* s, char* m1, dym* d, dym* conf, bool uncertainty, char* m2)<TD>???<TD>
	<TR><TD><B>fprintf_dym_dym</B>(FILE* s, char* m1, dym* d1, char* m2, dym* d2, char* m3)<TD>???<TD>
	<TR><TD><B>fprintf_dym_dyv</B>(FILE* s, char* m1, dym* d1, char* m2, dyv* d2, char* m3)<TD>???<TD>
</TABLE>

Math Operations
<TABLE BORDER=1 BGCOLOR="lightgrey">
	<TR><TH>Function Name<TH>Description<TH>Performance<TH>Errors/Uncertainties</TR>
	<TR><TD><B>add_dyv_to_dym_row</B>(dym* this_dyv, dyv* src, int row)<TD>Adds the contents of $src to the selected row of this_dyv<TD>???<TD>
	<TR><TD><B>add_dyv_to_dym_col</B>(dym* this_dyv, dyv* src, int col)<TD>Adds the contents of $src to the selected col of this_dyv<TD>???<TD>
	<TR><TD><B>add_dym_row_to_dyv</B>(dym* this_dyv, dyv* targ, int row)<TD>Adds the contents of the selected row of this_dyv into the given dyv<TD>???<TD>
	<TR><TD><B>add_dym_col_to_dyv</B>(dym* this_dyv, dyv* targ, int col)<TD>Adds the contents of the selected col of this_dyv into the given dyv<TD>???<TD>
	<TR><TD><B>add_dyv_to_diag</B>(dym* this_dyv, dyv* src)<TD>Adds the contents of the given dyv to the diagonal of @this_dyv<TD>???<TD>
	<TR><TD>dym* <B>mk_add_dyv_to_diag</B>(dym* this_dyv, dyv* src)<TD>Adds the contents of the given dyv to the diagonal of @this_dyv, placing the results, plus the rest of @this_dyv (??), into the returned dym<TD>???<TD>
	<TR><TD><B>dym_scalar_mult</B>(dym* this_dyv, double v, dym* targ)<TD>copies all values in this_dyv, multiplied by v, into targ<TD>???<TD>
	<TR><TD>dym* <B>mk_scalar_mult</B>(dym* this_dyv, double v)<TD>copies all values in this_dyv, multiplied by v, into the returned dym<TD>???<TD>
	<TR><TD><B>dym_scalar_add</B>(dym* this_dyv, double v, dym* targ)<TD>copies all values in this_dyv, incrememted by v, into targ<TD>???<TD>
	<TR><TD>dym* <B>mk_dym_scalar_add</B>(dym* this_dyv, double v, dym* targ)<TD>copies all values in this_dyv, incrememted by v, into returned dym<TD>???<TD>
	<TR><TD><B>dym_plus</B>(dym* d1, dym* d2, dym* targ)<TD>Foreach position in targ, assigns value of sum of corrisponding positions in d1 and d2<TD>???<TD>
	<TR><TD>dym* <B>mk_dym_plus</B>(dym* d1, dym* d2)<TD>Foreach position in the returned dym, assigns value of sum of corrisponding positions in d1 and d2<TD>???<TD>
	<TR><TD><B>dym_minus</B>(dym* d1, dym* d2, dym* targ)<TD>Foreach position in targ, assigns value of difference of corrisponding positions in d1 and d2<TD>???<TD>
	<TR><TD>dym* <B>mk_dym_minus</B>(dym* d1, dym* d2)<TD>Foreach position in the returned dym, assigns value of difference of corrisponding positions in d1 and d2<TD>???<TD>
	<TR><TD><B>dym_subtract</B>(dym* d1, dym* d2, dym* targ)<TD><B>IS THIS THE SAME THING AS DYM_MINUS???</B><TD>???<TD>
	<TR><TD>dym* <B>mk_dym_subtract</B>(dym* d1, dym* d2)<TD><B>IS THIS THE SAME THING AS MK_DYM_MINUS???</B><TD>???<TD>
	<TR><TD><B>dym_times_dyv</B>(dym* a, dyv* b, dyv* result)<TD>Places into @result a*b<TD>???<TD>
	<TR><TD>dyv* <B>mk_dym_times_dyv</B>(dym* a, dyv* b)<TD>Returns the result of a*b<TD>???<TD>
	<TR><TD><B>dym_mult</B>(dym* a, dym* b, dym* result)<TD>Places into @result a*b<TD>???<TD>
	<TR><TD>dym* <B>mk_dym_mult</B>(dym* a, dym* b)<TD>Returns the result of a*b<TD>???<TD>
	<TR><TD><B>dym_outer_product</B>(dym* a, dym* b, dym* result)<TD>Places into @result the outer product of a and b<TD>???<TD>
	<TR><TD>dym* <B>mk_dym_outer_product</B>(dym* a, dym* b)<TD>Returns the outer product of a and b<TD>???<TD>
	<TR><TD><B>dym_transpose</B>(dym* a, dym* result)<TD>Places into @result the transpose of @a<TD>???<TD>
	<TR><TD>dym* <B>mk_dym_transpose</B>(dym* a)<TD>Returns the transpose of @a<TD>???<TD>
	<TR><TD><B>dym_scale_rows</B>(dym* a, dyv* w_diag, dym* result)<TD>???<TD>???<TD>
	<TR><TD>dym* <B>mk_dym_scale_rows</B>(dym* a, dyv* w_diag)<TD>???<TD>???<TD>
	<TR><TD><B>dym_scale_cols</B>(dym* a, dyv* w_diag, dym* result)<TD>???<TD>???<TD>
	<TR><TD>dym* <B>mk_dym_scale_cols</B>(dym* a, dyv* w_diag)<TD>???<TD>???<TD>
	<TR><TD>double <B>dym_determinant</B>(dym* a)<TD>Returns the LU-determinant of square matrix @a<TD>???<TD>0 if a is singular
	<TR><TD>double <B>dym_log_determinant</B>(dym* a)<TD><TD>???<TD>
	<TR><TD><B>dym_solve_vector</B>(dym* a, dyv* b, dyv* r_x)<TD>???<TD>???<TD>
	<TR><TD>dym* <B>mk_dym_solve_vector</B>(dym* a, dyv* b)<TD>???<TD>???<TD>
	<TR><TD><B>invert_dym</B>(dym* a, dym* targ)<TD>Places the inverse of @a in @targ<TD>???<TD>
	<TR><TD>dym* <B>mk_invert_dym</B>(dym* a)<TD>Returns the inverse of @a<TD>???<TD>
	<TR><TD>bool <B>is_dym_symmetric</B>(dym* a)<TD>Returns TRUE if the dym is symmetric<TD>???<TD>
	<TR><TD><B>invert_symmetric_dym</B>(dym* a, dym* targ)<TD>Places the inverse of symmetric @a into @targ<TD>???<TD>
	<TR><TD>dym* <B>mk_invert_symmetric_dym</B>(dym* a)<TD>Returns the inverse of symmetric @a<TD>???<TD>
	<TR><TD>dyv* <B>mk_solve_lot_equation</B>(dym* lot, dyv* b)<TD>??<TD>???<TD>
	<TR><TD><B>tri_backsub</B>(dym* l, dyv* b, dyv *x)<TD>??<TD>???<TD>
	<TR><TD>dyv* <B>mk_tri_backsub</B>(dym* l, dyv* b)<TD>??<TD>???<TD>
	<TR><TD><B>tri_trans_backsub</B>(dym* l, dyv* b, dyv *x)<TD>??<TD>???<TD>
	<TR><TD>dyv* <B>mk_tri_trans_backsub</B>(dym* l, dyv* b)<TD>??<TD>???<TD>
	<TR><TD><B>cholesky_backsub</B>(dym* l, dyv* b, dyv *x)<TD>??<TD>???<TD>
	<TR><TD>dyv* <B>mk_cholesky_backsub</B>(dym* l, dyv* b)<TD>??<TD>???<TD>
	<TR><TD><B>cholesky_solve</B>(dym* a, dyv* b, dyv *x)<TD>??<TD>???<TD>
	<TR><TD>dyv* <B>mk_cholesky_solve</B>(dym* a, dyv* b)<TD>??<TD>???<TD>
	<TR><TD><B>dym_times_dyv_subset</B>(dym* a, dyv* x, dyv *r, ivec* goodarows, ivec* goodacols, ivec* goodrrows)<TD>??<TD>???<TD>
	<TR><TD>dyv* <B>mk_dym_times_dyv_subset</B>(dym* a, dyv* x, ivec* goodarows, ivec* goodacols, ivec* goodrrows)<TD>??<TD>???<TD>
	<TR><TD><B>dym_transpose_times_dyv_subset</B>(dym* a, dyv* x, dyv *r, ivec* goodarows, ivec* goodacols, ivec* goodrrows)<TD>??<TD>???<TD>
	<TR><TD>dyv* <B>mk_dym_transpose_times_dyv_subset</B>(dym* a, dyv* x, ivec* goodarows, ivec* goodacols, ivec* goodrrows)<TD>??<TD>???<TD>
	<TR><TD><B>dym_mult_subset</B>(dym* a, dym* b, dym *r, ivec* goodarows, ivec* goodacols, ivec* goodbcols, ivec* goodrrows, ivec* goodrcols)<TD>??<TD>???<TD>
	<TR><TD>dym* <B>mk_dym_mult_subset</B>(dym* a, dym* b, ivec* goodarows, ivec* goodacols, ivec* goodbcols, ivec* goodrrows, ivec* goodrcols)<TD>??<TD>???<TD>
	<TR><TD><B>robust_tri_backsub</B>(dym* l, dyv* b, dyv *x, ivec* goodlist)<TD>??<TD>???<TD>
	<TR><TD><B>robust_tri_trans_backsub</B>(dym* l, dyv* b, dyv *x, ivec* goodlist)<TD>??<TD>???<TD>
	<TR><TD><B>robust_cholesky_backsub</B>(dym* l, dyv* b, dyv *x, ivec* goodlist)<TD>??<TD>???<TD>
	<TR><TD>ivec* <B>attempt_robust_cholesky_decomp_in_place</B>(dym* a, ivec* skiplist)<TD>??<TD>???<TD>
	<TR><TD>bool <B>attempt_cholesky_decomp_in_place</B>(dym* a)<TD>??<TD>???<TD>
	<TR><TD>bool <B>invert_from_cholesky</B>(dym* l, dym* targ)<TD>??<TD>???<TD>
	<TR><TD>dym* <B>mk_invert_from_cholesky</B>(dym* l)<TD>??<TD>???<TD>
	<TR><TD>bool <B>attempt_cholesky_decomp</B>(dym* a, dym* targ)<TD>??<TD>???<TD>
	<TR><TD>bool <B>invert_spd_cholesky</B>(dym* l, dym* targ)<TD>??<TD>???<TD>
	<TR><TD>dym* <B>mk_invert_spd_cholesky</B>(dym* l)<TD>??<TD>???<TD>
	<TR><TD>bool <B>is_dym_symmetric_positive_definite</B>(dym* d)<TD>??<TD>???<TD>
	<TR><TD>dyv* <B>mk_min_dyv</B>(dym* d)<TD>Returns a dyv consisting of minimal values for each col<TD>???<TD>
	<TR><TD>dyv* <B>mk_max_dyv</B>(dym* d)<TD>Returns a dyv consisting of maximal values for each col<TD>???<TD>
	<TR><TD>double <B>dym_min</B>(dym* d)<TD>Returns smallest value in the given dym<TD>???<TD>
	<TR><TD>double <B>dym_max</B>(dym* d)<TD>Returns largest value in the given dym<TD>???<TD>
	<TR><TD>double <B>dym_sum</B>(dym* d)<TD>Returns sum of values in the given dym<TD>???<TD>
	<TR><TD>double <B>dym_sum_row</B>(dym* d, int row)<TD>Returns sum of values in the given row of @dym<TD>???<TD>
	<TR><TD>double <B>dym_sum_col</B>(dym* d, int col)<TD>Returns sum of values in the given col of @dym<TD>???<TD>
	<TR><TD>double <B>dym_row_min</B>(dym* d, int row)<TD>Returns smallest value in the given row of @dym<TD>???<TD>
	<TR><TD>double <B>dym_row_max</B>(dym* d, int row)<TD>Returns largest value in the given row of @dym<TD>???<TD>
	<TR><TD>double <B>dym_col_min</B>(dym* d, int col)<TD>Returns smallest value in the given col of @dym<TD>???<TD>
	<TR><TD>double <B>dym_col_max</B>(dym* d, int col)<TD>Returns largest value in the given col of @dym<TD>???<TD>
	<TR><TD>double <B>dym_xt_a_x_value</B>(dyv* x, dym* a)<TD>???<TD>???<TD>
	<TR><TD><B>dym_ptq</B>(dym* p, dym* q, dym* dest)<TD>???<TD>???<TD>
	<TR><TD>dym* <B>mk_dym_ptq</B>(dym* p, dym* q)<TD>???<TD>???<TD>
	<TR><TD><B>dym_ptqp</B>(dym* p, dym* q, dym* dest)<TD>???<TD>???<TD>
	<TR><TD>dym* <B>mk_dym_ptqp</B>(dym* p, dym* q)<TD>???<TD>???<TD>
	<TR><TD><B>dym_transpose_times_dyv</B>(dym* p, dyv* v, dyv* dest)<TD>???<TD>???<TD>
	<TR><TD>dyv* <B>mk_dym_transpose_times_dyv</B>(dym* p, dyv* v)<TD>???<TD>???<TD>
	<TR><TD>bool <B>attempt_lu_decomp</B>(dym* a, dym* l, dym* u)<TD>??<TD>???<TD>
	<TR><TD>bool <B>dym_is_ill_defined</B>(dym* a)<TD>TRUE if any elements are NaN or Infinity<TD>???<TD>
</TABLE>
There are also functions that deal with standard C arrays <B>farr</B> (array of doubles) and <B>tdarr</B> (2d array of doubles)
<TABLE BORDER=1 BGCOLOR="grey">
	<TR><TH>Function Name<TH>Description<TH>Performance<TH>Errors</TR>
	<TR><TD><B>copy_dym_to_tdarr</B>(dym* this_dym, double** tdarr)<TD>Copies a dym into a 2d double array<TD>???<TD>
	<TR><TD>double** <B>mk_tdarr_from_dym</B>(dym* this_dym)<TD>Returns a 2d double array with copy of contents of $this_dym<TD>???<TD>
	<TR><TD><B>copy_tdarr_to_dym</B>(double** tdarr, int rows, int cols, dym* my_dym)<TD>Copies a 2d double array into $my_dym<TD>What if $my_dym isn't big enough currently, or has stuff in it?
	<TR><TD>dym* <B>mk_dym_from_tdarr</B>(double** tdarr, int rows, int cols)<TD>Returns a new dym, copied from $tdarr<TD>...
	<TR><TD><B>copy_farr_to_dym_row</B>(double* farr, dym* my_dym, int row)<TD>Copies a 1d array into $my_dym at the given row<TD>Does this replace or insert?
	<TR><TD><B>copy_farr_to_dym_col</B>(double* farr, dym* my_dym, int col)<TD>Copies a 1d array into $my_dym at the given col<TD>Does this replace or insert?
	<TR><TD><B>copy_dym_row_to_farr</B>(dym* my_dym, double* farr, int row)<TD>Copies specified dym row into a 1d array<TD>Does this replace or insert?
	<TR><TD><B>copy_dym_col_to_farr</B>(dym* my_dym, double* farr, int col)<TD>Copies specified dym col into a 1d array<TD>Does this replace or insert?
	<TR><TD>double* <B>mk_farr_from_dym_row</B>(dym* my_dym, int row)<TD>Builds a 1d array from specified dym row<TD>
	<TR><TD>double* <B>mk_farr_from_dym_col</B>(dym* my_dym, int col)<TD>Builds a 1d array from specified dym col<TD>
	<TR><TD>dym* <B>mk_col_dym_from_farr</B>(double* farr, int farr_size)<TD>???<TD>
	<TR><TD>dym* <B>mk_row_dym_from_farr</B>(double* farr, int farr_size)<TD>???<TD>
	<TR><TD>dym* <B>mk_diag_dym_from_farr</B>(double* farr, int farr_size)<TD>Returns a diagonal dym with the contents of the given array of given size<TD>
	<TR><TD>double** <B>mk_nrecipes_matrix_from_dym</B>(dym* d)<TD>??<TD>???<TD>
	<TR><TD><B>copy_nrecipes_matrix_to_dym</B>(double** nrtdarr, dym* d)<TD>??<TD>???<TD>
	<TR><TD><B>free_nrecipes_matrix</B>(double** nrtdarr, dym* d)<TD>??<TD>???<TD>
</TABLE>
<H1>Implementation</H1>
	<FONT COLOR="red">Just because this is here does not mean you should violate abstraction.</FONT>
<PRE>
struct
{
	int dym_code; <B>// Makes sure someone didn't just malloc us instead of using our constructors, which set this field to 1</B>
	int rows; <B>// How many rows we hold</B>
	int cols; <B>// How many cols we hold</B>
	int rows_allocated; <B>// How many rows are currently allocated</B>
	double **tdarr; <B>// Pointer into the actual data</B>
}
</PRE>
</BODY></HTML>
