<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML><HEAD><TITLE>Dynamic Vector Documentation</TITLE></HEAD>
<BODY BGCOLOR="#AAACCC">
<H1>Dynamic Vector Documentation</H1>
Vectors (arrays/1d matrices) are useful, common data
structures. Our implementation of Dynamic Vectors allows
for (semi)easy resizing of vectors and provides useful operations
over the members. Dynamic vectors hold values of the type
<B>double</B>.<br><br>
<HR>
Usage:
<UL>
	<LI>#include "amdyv.h" (in <B>utils/</B> )
	<LI>Link with libutils.a (if you're using the auton build system, list utils as a sibling)
</UL>
<HR>


Size/Allocation Operations
<TABLE BORDER=1 BGCOLOR="palegreen">
	<TR><TH>Function Name<TH>Description<TH>Performance<TH>Errors</TR>
	<TR><TD>dyv* <B>mk_dyv</B>(int size)<TD>Returns a new dyv of size $size.<TD>???<TD>What are the values initialized to? What if you pass a negative size?
	<TR><TD>dyv* <B>mk_dyv_x</B>(int size,double ...)<TD>Returns a new dyv of size $size initialized with provided values<TD>???<TD>What are the values initialized to for elements beyond those specified? What if you pass a negative size? What if you pass more elements than the size can handle? Although we can't guarantee this to be well-behaved in ANSI C, we can, with #ifdefs, make it safer on GCC and help ourselves catch bugs. 
	<TR><TD>dyv* <B>mk_dyv_1 (up to 6)</B>(double value ...)<TD>Makes a dyv with the given number of elements<TD>???<TD>
	<TR><TD><B>free_dyv</B>(dyv* this_dyv)<TD>Release this_dyv<TD>???<TD>
	<TR><TD>int <B>dyv_size</B>(dyv* this_dyv)<TD>Returns size of $this_dyv<TD>???<TD>
	<TR><TD><B>dyv_destructive_resize</B>(dyv* this_dyv, int size)<TD>Reallocates dyv with new size, losing all data previously in dyv<TD>
	<TR><TD><B>dyv_increase_length</B>(dyv* this_dyv, int length_increment)<TD>Makes a dyv longer by $length_increment?<TD>???<TD>What if $length_increment is negative?
	<TR><TD><B>add_to_dyv</B>(dyv* this_dyv, int new_val)<TD>Adds a new element $new_val? Increments each element by $new_val? Not sure which<TD>???<TD>
	<TR><TD><B>dyv_remove</B>(dyv* this_dyv, int index)<TD>Removes element at index $index, shrinking array as needed<TD>???<TD>
	<TR><TD><B>dyv_remove_last_element</B>(dyv* this_dyv)<TD>Removes last element, shrinking array as needed<TD>???<TD>
	<TR><TD><B>dyv_insert</B>(dyv* this_dyv, int index, double value)<TD>Insert $value at $index, scooting existing elemnts to the right<TD>???<TD>
	<TR><TD>dyv* <B>mk_constant_dyv</B>(int size, double value)<TD>???<TD>???<TD>
	<TR><TD>dyv* <B>mk_zero_dyv</B>(int size)<TD>???<TD>???<TD>
	<TR><TD>dyv* <B>mk_user_input_dyv</B>(char* message, int dims)<TD>???<TD>???<TD>
	<TR><TD>dyv* <B>mk_basic_dyv_from_args</B>(char* name, int argc, char** argv, int size)<TD>???<TD>???<TD>
	<TR><TD>dyv* <B>mk_dyv_from_args</B>(char* name, int argc, char** argv, dyv* default)<TD>???<TD>???<TD>
	<TR><TD>double* <B>mk_nrecipes_vector_from_dyv</B>(dyv* d)<TD>???<TD>???<TD>
</TABLE>

Basic Operations
<TABLE BORDER=1 BGCOLOR="white">
	<TR><TH>Function Name<TH>Description<TH>Performance<TH>Errors</TR>
	<TR><TD><B>dyv_set</B>(dyv* this_dyv, int index, double value)<TD>Set value at position $index to $value?<TD>???<TD>
	<TR><TD><B>constant_dyv</B>(dyv* this_dyv, double value)<TD>???<TD>???<TD>
	<TR><TD><B>zero_dyv</B>(dyv* this_dyv)<TD>???<TD>???<TD>
	<TR><TD>bool <B>zero_dyvp</B>(dyv* this_dyv)<TD>???<TD>???<TD>
	<TR><TD><B>fprintf_dyv</B>(FILE* s, char* m1, dyv* d, char* m2)<TD>???<TD>???<TD>
</TABLE>
Math Operations
<TABLE BORDER=1 BGCOLOR="lightgrey">
	<TR><TH>Function Name<TH>Description<TH>Performance<TH>Errors/Uncertainties</TR>
	<TR><TD><B>safe_dyv_increment</B>(dyv* this_dyv, int index, double value)<TD>???<TD>???<TD>
	<TR><TD><B>dyv_mult</B>(dyv* d1, dyv* d2, dyv* target)<TD>???<TD>???<TD>
	<TR><TD>dyv* <B>mk_dyv_mult</B>(dyv* d1, dyv* d2)<TD>???<TD>???<TD>
	<TR><TD><B>dyv_scalar_mult</B>(dyv* d1, double src2, dyv* target)<TD>???<TD>???<TD>
	<TR><TD>dyv* <B>mk_dyv_scalar_mult</B>(dyv* d1, double src2)<TD>???<TD>???<TD>
	<TR><TD><B>dyv_scalar_add</B>(dyv* d1, double src2, dyv* target)<TD>???<TD>???<TD>
	<TR><TD>dyv* <B>mk_dyv_scalar_add</B>(dyv* d1, double src2)<TD>???<TD>???<TD>
	<TR><TD><B>dyv_scalar_madd</B>(double factor, dyv* d1, double d2, dyv* target)<TD>???<TD>???<TD>
	<TR><TD>dyv* <B>mk_dyv_scalar_madd</B>(double factor, dyv* d1, double d2)<TD>???<TD>???<TD>
	<TR><TD><B>copy_dyv</B>(dyv* src, dyv* target)<TD>???<TD>???<TD>
	<TR><TD>dyv* <B>mk_copy_dyv</B>(dyv* src)<TD>???<TD>???<TD>
	<TR><TD><B>dyv_plus</B>(dyv* src, dyv* src2, dyv* target)<TD>???<TD>???<TD>
	<TR><TD>dyv* <B>mk_dyv_plus</B>(dyv* src1, dyv* src2)<TD>???<TD>???<TD>
	<TR><TD><B>dyv_subtract</B>(dyv* src, dyv* src2, dyv* target)<TD>???<TD>???<TD>
	<TR><TD>dyv* <B>mk_dyv_subtract</B>(dyv* src1, dyv* src2)<TD>???<TD>???<TD>
	<TR><TD>double <B>dyv_scalar_product</B>(dyv* src1, dyv* src2)<TD>???<TD>???<TD>
	<TR><TD>double <B>dyv_dsqd</B>(dyv* src1, dyv* src2)<TD>???<TD>???<TD>
	<TR><TD>double <B>dyv_pnorm</B>(dyv* src, double p)<TD>???<TD>???<TD>
	<TR><TD>double <B>dyv_magnitude</B>(dyv* my_dyv)<TD>???<TD>???<TD>
	<TR><TD>int <B>index_in_sorted_dyv</B>(dyv* my_dyv, double value)<TD>???<TD>???<TD>
	<TR><TD><B>dyv_sort</B>(dyv* my_dyv, dyv* target)<TD>???<TD>???<TD>
	<TR><TD>dyv* <B>mk_dyv_sort</B>(dyv* my_dyv)<TD>???<TD>???<TD>
	<TR><TD>dyv* <B>mk_sorted_dyv_indices</B>(dyv* my_dyv)<TD>???<TD>???<TD>
	<TR><TD>double <B>dyv_sum</B>(dyv* my_dyv)<TD>???<TD>???<TD>
	<TR><TD>double <B>dyv_mean</B>(dyv* my_dyv)<TD>Returns mean of $my_dyv<TD>What if $my_dyv is empty?<TD>
	<TR><TD>double <B>dyv_median</B>(dyv* my_dyv)<TD>Returns median of $my_dyv<TD>What if $my_dyv is empty?<TD>
	<TR><TD>double <B>dyv_sdev</B>(dyv* my_dyv)<TD>???<TD>???<TD>
	<TR><TD>double <B>dyv_min</B>(dyv* my_dyv)<TD>Returns minimum element in $my_dyv<TD>What if $my_dyv is empty?<TD>
	<TR><TD>double <B>dyv_max</B>(dyv* my_dyv)<TD>Returns the maximum element in $my_dyv<TD>What if $my_dyv is empty?<TD>
	<TR><TD>double <B>dyv_argmin</B>(dyv* my_dyv)<TD>???<TD>???<TD>
	<TR><TD>double <B>dyv_argmax</B>(dyv* my_dyv)<TD>???<TD>???<TD>
	<TR><TD><B>dyv_reciprocal</B>(dyv* my_dyv, dyv* target)<TD>$target becomes array with reciprocal of all values in $my_dyv (Here, reciprocal of 0 is 0)<TD>???<TD>
	<TR><TD>dyv* <B>mk_dyv_reciprocal</B>(dyv* my_dyv)<TD>???<TD>???<TD>
	<TR><TD><B>dyv_element_times</B>(dyv* src1, dyv* src2, dyv* target)<TD>???<TD>???<TD>
	<TR><TD>double <B>xt_diag_x_value</B>(dyv* x, dyv* a)<TD>???<TD>???<TD>
	<TR><TD>bool <B>dyv_is_ill_defined</B>(dyv* my_dyv)<TD>Are there any infinities/NaNs in the dyv?<TD>???<TD>
	<TR><TD>dyv* <B>mk_dyv_scalar_combine</B>(dyv* a, dyv* b, double a_weight, double b_weight)<TD>???<TD>???<TD>
	<TR><TD>int <B>dyv_num_unique_values</B>(dyv* this_dyv)<TD>Returns the number of unique elements in $this_dyv ?<TD>???<TD>
	<TR><TD><B>assert_dyv_shape</B>(dyv* d, int size, char* name)<TD>???<TD>???<TD>
	<TR><TD><B>check_dyv_code</B>(dyv* d, char* name)<TD>???<TD>???<TD>
</TABLE>
There are also functions that deal with standard C arrays <B>farr</B> (array of doubles) and <B>tdarr</B> (2d array of doubles)
<TABLE BORDER=1 BGCOLOR="grey">
	<TR><TH>Function Name<TH>Description<TH>Performance<TH>Errors</TR>
	<TR><TD>int <B>copy_dyv_to_farr</B>(dyv* this_dyv, double* farr)<TD>???<TD>???<TD>
	<TR><TD>double* <B>mk_farr_from_dyv</B>(dyv* this_dyv)<TD>???<TD>???<TD>
	<TR><TD><B>copy_farr_to_dyv</B>(double* farr, int size, dyv* this_dyv)<TD>???<TD>???<TD>
	<TR><TD>dyv* <B>mk_dyv_from_farr</B>(double* farr, int size)<TD>???<TD>???<TD>
	<TR><TD><B>copy_dyv_to_tdarr_row</B>(dyv* this_dyv, double** tdarr, int row)<TD>???<TD>???<TD>
	<TR><TD><B>copy_dyv_to_tdarr_col</B>(dyv* this_dyv, double** tdarr, int col)<TD>???<TD>???<TD>
	<TR><TD><B>copy_tdarr_row_to_dyv</B>(double** tdarr, dyv* my_dyv, int row)<TD>???<TD>???<TD>
	<TR><TD>dyv* <B>mk_dyv_from_tdarr_row</B>(double* tdarr, int row, int tdarr_cols)<TD>???<TD>???<TD>
	<TR><TD><B>copy_tdarr_col_to_dyv</B>(double** tdarr, dyv* my_dyv, int col)<TD>???<TD>???<TD>
	<TR><TD>dyv* <B>mk_dyv_from_tdarr_col</B>(double** tdarr, int col, int tdarr_rows)<TD>???<TD>???<TD>
	<TR><TD><B>copy_nrecipes_vector_to_dyv</B>(double* nrfarr, dyv* d)<TD>???<TD>???<TD>
	<TR><TD><B>free_nrecipes_vector</B>(double* nrfarr, dyv* d)<TD>???<TD>???<TD>
</TABLE>
<H1>Implementation</H1>
	<FONT COLOR="red">Just because this is here does not mean you should violate abstraction.</FONT>
<PRE>
struct
{
	int dyv_code; <B>// Makes sure someone didn't just malloc us instead of using our constructors, which set this field to 1</B>
	int array_size; <B>// How many values we hold</B>
	int size; <B>// How many values are allocated</B>
	double *farr; <B>// Pointer into the actual data</B>
}
</PRE>
</BODY></HTML>
</BODY></HTML>
